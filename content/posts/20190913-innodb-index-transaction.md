---
title: "InnoDB事务及索引原理"
date: 2019-09-13T20:40:13+08:00
draft: true
toc: true
---

> InnoDB是MySQL的默认存储引擎（5.1版本及以上），通过日志和锁来实现事务的特性，采用B+树来作为索引的数据结构。

## 事务的ACID特性

1. 原子性(Atomicity)：一个事务中的所有操作要么全部提交成功，要么全部失败回滚，不会结束在中间的某个环节。
2. 一致性(Consistency)：数据库总是从一个一致性的状态转换到另一个一致性的状态。
3. 隔离性(Isolation)：事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见。
4. 持久性(Durability)：事务一旦提交，其结果是永久性的，就算发生宕机等故障，数据库也能将数据恢复。
<!--more-->

![transaction](/assets/article/20190913/transaction.jpg)

## 事务日志
InnoDB 使用undo、 redo log来保证事务原子性、一致性及持久性，同时采用预写日志方式将随机写入变成顺序追加写入，提升事务性能。

+ **undo log** ：记录事务变更前的状态。操作数据之前，先将数据备份到undo log，然后进行数据修改，如果出现错误或用户执行了rollback语句，则系统就可以利用undo log中的备份数据恢复到事务开始之前的状态。
+ **redo log**:记录事务变更后的状态。在事务提交前，只要将redo log持久化即可，数据在内存中变更。当系统崩溃时，虽然数据没有落盘，但是redo log已持久化，系统可以根据redo Log的内容，将所有数据恢复到最新的状态。
+ **checkpoint**:随着时间的积累，redo Log会变的很大很大。如果每次都从第一条记录开始恢复，恢复的过程就会很慢。为了减少恢复的时间，就引入了Checkpoint机制。定期将databuffer的内容刷新到磁盘datafile内，然后清除checkpoint之前的redo log。
+ **恢复**：InnoDB通过 加载最新快照，然后重做checkpoint之后所有事务（包括未提交和回滚了的），再通过undo log回滚那些未提交的事务，来完成数据恢复。需要注意的地方是，undo 日志其实也是行数据，对其写操作也会记录到redo log内，即undo log也是通过redo log来保证持久化的。

InnoDB实现事务的ACID特性

原子性 | 回滚日志（Undo Log）：用于记录数据修改前的状态
---|---
一致性 | 重做日志（Redo Log）：用于记录数据修改后的状
隔离性 | 使用共享锁和排他锁对资源隔离
持久性 | 重做日志（Redo Log）+回滚日志（Undo Logo）

以银行汇款为例子一个事务的执行过程
![redo-undo-log](/assets/article/20190913/bank.png)

## 事务隔离级别

+ 读未提交(READ-UNCOMMITTED):事务中的修改，即使没有提交，对其它事务也是可见的。任何操作都不加锁。
+ 读已提交(READ-COMMITTED):一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。数据的读取不加锁，但数据的写入、修改和删除都加锁。
+ 可重复读(REPEATABLE-READ):InnoDB默认隔离级别，保证在同一个事务中多次读取同样数据的结果是一样的。MVCC机制让数据变得可重复读。
+ 串行化(SERIALIZABLE):强制事务串行执行。全部操作加悲观锁。读加共享锁，写加排他锁。

## 事务并发访问问题

+ 更新丢失：一个事务的更新覆盖了另一个事务的更新，现在的数据库都会加锁来防止更新丢失，在所有的事务隔离级别均可避免
+ 脏读：一个事务读取到另一个事务未提交数据，READ-COMMITTED事务隔离级别以上可以避免
+ 不可重复读：一个事务多次读取统一数据时结果不一致，REPEATABLE-READ事务隔离级别以上可以避免
+ 幻读： 事务B通过插入删除的方式修改事务A的结果集导致事务A就像出现幻觉一样，SERIALIZABLE事务隔离级别以上可以避免，但是InnoDB却在REPEATABLE-READ事务隔离级别避免了幻读问题

事务隔离级别|更新丢失|脏读|不可重复读|幻读
---|---|---|---|---
未提交读 | 避免 | 发生 | 发生 | 发生
已提交读 | 避免 | 避免 | 发生 | 发生
可重复读 | 避免 | 避免 | 避免 | 发生
串行化   | 避免 | 避免 | 避免 | 避免

## InnoDB可重复读隔离级别下避免幻读原因

表象：快照读（非阻塞读）--MVCC

内在：next-key锁（行锁+Gap锁）

### 当前读与快照读

当前读：即加了锁的增删改查：select...lock in share mode,select...for update,update,insert,delete读取的是记录的最新版本，并且返回的记录都会加上锁保证其他事务不会再修改该记录
快照读：不加锁的非阻塞读（事务隔离级别在SERIALIZABLE的读取是串行化的快照读也会退化成当前读），通过[MVCC (Multi-Version Concurrency Control)](https://en.wikipedia.org/wiki/Multiversion_concurrency_control) 多版本并发控制协议机制实现

### Gap锁

对主键索引或唯一索引如果where条件全部命中，则不会加Gap锁，只加记录锁；如果where条件部分命中或全不命中，则加Gap锁

Gap锁也会用在非唯一索引或不走索引的当前读中

## InnoDB逻辑存储结构

MySQL表中的所有数据被存储在一个空间内，称之为表空间，表空间内部又可以分为段(segment)、区(extent)、页(page)、行(row)
![InnoDB逻辑存储结构](/assets/article/20190913/innodb-logical-structure.jpg)

+ 段(segment)
表空间是由不同的段组成的，常见的段有:数据段，索引段，回滚段等等，在 MySQL中，数据是按照B+树来存储，因此数据即索引，因此数据段即为B+树的叶子节点，索引段为B+树的非叶子节点,回滚段用于存储undo日志，用于事务失败后数据回滚以及在事务未提交之前通过undo日志获取之前版本的数据，在InnoDB1.1版本之前一个InnoDB,只支持一个回滚段，支持1023个并发修改事务同时进行，在InnoDB1.2版本，将回滚段数量提高到了128个，也就是说可以同时进行128*1023个并发修改事务。

+ 区(extent)
区是由连续页组成的空间，每个区的固定大小为1MB,为保证区中页的连续性，InnoDB会一次从磁盘中申请4~5个区，在默认不压缩的情况下，一个区可以容纳64个连续的页。但是在开始新建表的时候，空表的默认大小为96KB,是由于为了高效的利用磁盘空间，在开始插入数据时表会先利用32个页大小的碎片页来存储数据，当这些碎片使用完后，表大小才会按照MB倍数来增加。

+ 页(page)
页是InnoDB存储引擎的最小管理单位，每页大小默认是16KB，从InnoDB 1.2.x版本开始，可以利用innodb_page_size来改变页size，但是改变只能在初始化InnoDB实例前进行修改，之后便无法进行修改，除非mysqldump导出创建新库，常见的页类型有:数据页、undo页、系统页、事务数据页、插入缓冲位图页、插入缓冲空闲列表页、未压缩的二进制大对象页、压缩的二进制大对象页。

+ 行(row)
行对应的是表中的行记录，每页存储最多的行记录也是有硬性规定的最多16KB/2-200,即7992行
![row](/assets/article/20190913/innodb-row-struct.jpg)
    + 变长字段长度列表:此字段标识列字段的长度，与列字段顺序相反存放，若列长度小于255字节，用一个字节表示，若大于255字节，用两个字节表示，这也是 MySQL的VARCHAR类型最大长度限制为65535
    + NULL标志位:标识改列是否有空字段，有用1表示，否则为0，该标志位长度为ceil(N/8)
    + 记录头信息:固定用5字节表示，具体含义如下:
        + 列数据:此行存储着列字段数据，Null是不占存储空间的
        + 隐藏列:事务id和回滚列id,分别占用6、7字节，若此表没有主键，还会增加6字节的rowid列

## B+树

一个 m 阶的[B树](/assets/article/20190913/https://zh.wikipedia.org/wiki/B%E6%A0%91)是一个有以下属性的树:

1. 每一个节点最多有 m 个子节点
2. 每一个非叶子节点（除根节点）最少有ceil(m/2)个子节点
3. 如果根节点不是叶子节点，那么它至少有两个子节点
4. 有 k 个子节点的非叶子节点拥有 k − 1 个键
5. 所有的叶子节点都在同一层

而[B+树](/assets/article/20190913/https://baike.baidu.com/item/B%2B%E6%A0%91)是B树的一种变形形式但:

1. 非叶子节点子树的指针与关键字个数相同
2. 非叶子节点的子树指针p[i]指向( k[i] , k[i+1] ]
3. 非叶子节点近做索引，数据都保存在叶子节点中
4. 所有叶子节点均有一个链指针指向下一个叶子节点

B+ 树元素自底向上插入，这与二叉树恰好相反,B+树的插入必须保证插入后叶节点中的记录依然排序，同时需要考虑插入B+树的三种情况，每种情况都可能会导致不同的插入算法，插入算法入下图:

![insert B+tree](/assets/article/20190913/b+tree-insert.png)

插入举例(未加入双向链表):

1. 插入28这个键值，发现当前Leaf Page和Index Page都没有满，直接插入。
![](/assets/article/20190913/28.png)
2. 插入70这个键值，Leaf Page已经满了，但是Index Page还没有满，根据中间的值60拆分叶节点。
![](/assets/article/20190913/70.png)
3. 插入记录95，Leaf Page和Index Page都满了，这时需要做两次拆分
![](/assets/article/20190913/95.png)
4. B+树总是会保持平衡。但是为了保持平衡，对于新插入的键值可能需要做大量的拆分页（split）操作，而B+树主要用于磁盘，因此页的拆分意味着磁盘数据移动，应该在可能的情况下尽量减少页的拆分。因此，B+树提供了旋转（rotation）的功能。旋转发生在Leaf Page已经满了、但是其左右兄弟节点没有满的情况下。这时B+树并不会急于去做拆分页的操作，而是将记录移到所在页的兄弟节点上。通常情况下，左兄弟被首先检查用来做旋转操作，在第一张图情况下，插入键值70，其实B+树并不会急于去拆分叶节点，而是做旋转，50，55，55旋转。
![](/assets/article/20190913/rotation.png)

B+树使用填充因子（fill factor）来控制树的删除变化，50%是填充因子可设的最小值。B+树的删除操作同样必须保证删除后叶节点中的记录依然排序，同插入一样，B+树的删除操作同样需要考虑下图所示的三种情况，与插入不同的是，删除根据填充因子的变化来衡量。

![deleteb B+tree](/assets/article/20190913/deleteb+tree.png)

删除示例(未加入双向链表):

1. 删除键值为70的这条记录，直接删除（在插入第三点基础上的图）
![](/assets/article/20190913/d70.png)
2. 接着我们删除键值为25的记录，该值还是Index Page中的值，因此在删除Leaf Page中25的值后，还应将25的右兄弟节点的28更新到Page Index中。
![](/assets/article/20190913/d25.png)
3. 删除键值为60的情况，删除Leaf Page中键值为60的记录后，填充因子小于50%，这时需要做合并操作，同样，在删除Index Page中相关记录后需要做Index Page的合并操作。
![](/assets/article/20190913/d60.png)

## 聚簇索引和二级索引

### 聚簇索引

每个InnoDB的表都拥有一个索引，称之为聚簇索引，此索引中存储着行记录，一般来说，聚簇索引是根据主键生成的。

聚簇索引按照如下规则创建:

+ 当定义了主键后，InnoDB会利用主键来生成其聚簇索引;
+ 如果没有主键，InnoDB会选择一个非空的唯一索引来创建聚簇索引;
+ 如果这也没有，InnoDB会隐式的创建一个自增的列来作为聚簇索引。

> 对于选择唯一索引的顺序是按照定义唯一索引的顺序，而非表中列的顺序, 同时选中的唯一索引字段会充当为主键，或者InnoDB隐式创建的自增列也可以看做主键。

聚簇索引整体是一棵B+树，非叶子节点存放的是键值，叶子节点存放的是行数据，称之为数据页，这就决定了表中的数据也是聚簇索引中的一部分，数据页之间是通过一个双向链表来链接的，上文说到B+树是一棵平衡查找树，也就是聚簇索引的数据存储是有序的，但是这个是逻辑上的有序，但是在实际的物理存储上不是，因为数据页之间是通过双向链表来连接，假如物理存储是顺序的话，那维护聚簇索引的成本非常的高。

### 辅助索引

除了聚簇索引之外的索引都可以称之为辅助索引，与聚簇索引的区别在于辅助索引的叶子节点中存放的是主键的键值。一张表可以存在多个辅助索引，但是只能有一个聚簇索引，通过辅助索引来查找对应的行记录的话，需要进行两步，第一步通过辅助索引来确定对应的主键，第二步通过相应的主键值在聚簇索引中查询到对应的行记录，也就是进行两次B+树搜索。相反通过辅助索引来查询主键的话，遍历一次辅助索引就可以确定主键了，也就是所谓的索引覆盖，不用回表（查询聚簇索引）。

创建辅助索引，可以创建单列的索引，也就是用一个字段来创建索引，也可以用多个字段来创建副主索引称为联合索引，创建联合索引后，B+树的节点存储的键值数量不是1个，而是多个，如下图:
![](/assets/article/20190913/2index.png)

+ 联合索引的B+树和单键辅助索引的B+树是一样的，键值都是排序的，通过叶子节点可以逻辑顺序的读出所有的数据，比如上图所存储的数据时，按照(a,b)这种形式(1,1),(1,2),(2,1),(2,4),(3,1),(3,2)进行存放，这样有个好处存放的数据时排了序的，当进行order by对某个字段进行排序时，可以减少复杂度，加速进行查询
+ 当用`select * from table where a=? and ?`可以使用索引(a,b)来加速查询，但是在查询时有一个原则，sql的where条件的顺序必须和二级索引一致，而且还遵循索引最左原则，`select * from table where b=?`则无法利用(a,b)索引来加速查询
+ 辅助索引还有一个概念便是索引覆盖，索引覆盖的一个好处便是辅助索引不包含行记录，因此其大小远远小于聚簇索引，利用辅助索引进行查询可以减少大量的IO操作

## SQL优化建议

索引有如下有点：减少服务器扫描的数据量、避免排序和临时表、将随机I/O变为顺序I/O

通过explain工具和慢日志可以分析SQL语句执行

### 可使用B+树索引的查询方式

1. 全值匹配：与索引中的所有列进行匹配，也就是条件字段与联合索引的字段个数与顺序相同；
2. 匹配最左前缀：只使用联合索引的前几个字段；
3. 匹配列前缀：比如like 'xx%'可以走索引；
4. 匹配范围值：范围查询，比如>,like等；
5. 匹配某一列并范围匹配另外一列：精确查找+范围查找；
6. 只访问索引查询：索引覆盖，select的字段为主键。

范围查询后的条件不会走索引

### 列的选择性（区分度）
选择性（区分度）是指不重复的列值个数/列值的总个数，一般意义上建索引的字段要区分度高，而且在建联合索引的时候区分度高的列字段要放在前边，这样可以在第一个条件就过滤掉大量的数据，有利用性能的提升，对于如何计算列的区分度，有如下两种方法：

+ 根据定义，手动计算列的区分度，不重复的列值个数/列值的总个数；
+ 通过 MySQL的carlinality，通过命令`show index from <table_name>`来查看，解释一下，此处的carlinality并不是准确值，而且 MySQL在B+树种选择了8个数据页来抽样统计的值，也就是说carlinality=每个数据页记录总和/8*所有的数据页，因此也说明这个值是不准确的，因为在插入/更新记录时，实时的去更新carlinality对于 MySQL的负载是很高的，如果数据量很大的话，触发 MySQL重新统计该值得条件是当表中的1/16数据发生变化时。



参考:  
[MySQL InnoDB 索引原理](https://zhuanlan.zhihu.com/p/35811482)