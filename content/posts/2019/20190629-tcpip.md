---
title: "Linux网络编程"
date: 2019-06-29T22:11:05+08:00
tags: ["Linux","TCP/IP"]
categories: ["嵌入式Linux操作系统笔记"]
toc : true
---

国际标准组织(ISO)制定了 OSI 模型。这个模型把网络通信的工作分为 7 层。每一层负责一项具体的工作,然后把数据传送到下一层。这个模型虽然规定得非常细致,但在实际应用中显得过于复杂了。
<!--more-->
![Osi reference model](/assets/article/20190629/osi_reference_model.png)

而TCP/IP协议则将OSI的7层模型简化为了4层,从而更有利于实现和使用。TCP/IP许多年来一直被人们所采用,而且越来越成熟。

![osi_to_tcp/ip](/assets/article/20190629/osi_to_tcpip.png)

1. 网络接口层:负责将二进制流转换为数据帧,并进行数据帧的发送和接收。数据帧是网络信息传输的基本单元。
2. 网络层:负责将数据帧封装成 IP 数据报,同时负责选择数据报的路径,即路由。
3. 传输层:负责端到端之间的通信会话连接与建立。传输协议的选择根据数据传输方式而定。
4. 应用层:负责应用程序的网络访问,这里通过端口号来识别各个不同的进程。

### TCP/IP协议族

TCP/IP协议实际是一个协议族,为网际数据通信提供不同层次的通路。可将 TCP/IP协议族上分为三部分

![tcpip_protocol_family](/assets/article/20190629/tcpip_protocol_family.png)

- 第一部分也称为网络层。主要包括Internet协议(IP)、网际控制报文协议(ICMP)和地址识别协议(ARP)。
    - Internet协议(IP):该协议被设计成互联分组交换通信网,以形成一个网际通信环境,它负责在源主机和目的地主机之间传输来自其较高层软件的称为数据报文的数据块,它在源和目的地之间提供非连接型传递服务。
    - 网际控制报文协议(ICMP):它实际上不是 IP 层部分,但直接同 IP 层一起工作,报告网络上的某些出错情况。允许网际路由器传输差错信息或测试报文。
    - 地址识别协议(ARP):ARP 实际上不是网络层部分,它处于 IP 和数据链路层之间,它是在 32 位 IP 地址和 48 位局域网地址之间执行翻译的协议。
- 第二部分是传输层协议。主要包括传输控制协议和用户数据报文协议。
    - 传输控制协议(TCP):由于 IP 提供非连接型传递服务,因此 TCP 应为应用程序存取网络创造了条件,使用可靠的面向连接的传输层服务。该协议为建立网际上用户进程之间的对话负责。此外,还确保两个以上进程之间的可靠通信。它所提供的功能包括:监听输入对话建立请求、请求另一网络站点对话、可靠的发送和接收数据和适度的关闭对话。
    - 用户数据报文协议(UDP):UDP 提供不可靠的非连接型传输层服务,它允许在源和目的地站点之间传送数据,而不必在传送数据之前建立对话。此外,该协议还不使用 TCP 使用的端对端差错校验。当使用 UDP 时,传输层功能全都发回,而开销却比较低。它主要用于那些不要求 TCP 协议的非连接型的应用程序。例如,名字服务和网络管理。
- 第三部分是应用程序部分。这部分包括 Telnet,文件传送协议(FTP 和 TFTP),简单的文件传送协议(SMTP)和域名服务(DNS)等协议。

### TCP和UDP

1. tcp协议处于传输层,实现了从一个应用程序到另一个应用程序的数据传递。应用程序通过目的地址和端口号来区分接收数据的不同应用程序。

(1)TCP 数据包格式

![TCPpacket](/assets/article/20190629/tcp_packet.png)

- 源端口和目的端口字段:各占 2 字节。端口是传输层与应用层的服务接口。传输层的复用和分用功能都要通过端口才能实现。
- 序号字段:占 4 字节。 TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。
- 确认号字段:占 4 字节,是期望收到对方的下一个报文段的数据的第一个字节的序号。
- HLEN 字段:占 4 bit,它指出首部长度,单位为字(32 bit 的字)。正常的TCP首部长度是 20 字节。
- 6个标志字段:占 6 bit。
    - 紧急比特 URG:当 URG = 1 时,表明紧急指针字段有效。它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)。
    - 确认比特 ACK:只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时,确认号无效。
    - 推送比特 PSH (PuSH):接收 TCP 收到推送比特置 1 的报文段,就尽快地交付给接收应用进程,而不再等到整个缓存都填满了后再向上交付。
    - 复位比特 RST (ReSeT):当 RST = 1 时,表明 TCP 连接中出现严重差错(如由于主机崩溃或其他原因),必须释放连接,然后再重新建立运输连接。
    - 同步比特 SYN :同步比特 SYN 置为 1,就表示这是一个连接请求或连接接受报文。
    - 终止比特FIN (FINal):用来释放一个连接。当 FIN = 1 时,表明此报文段的发送端的数据已发送完毕,并要求释放运输连接。
- 窗口字段: 占 2 字节。窗口字段用来控制对方发送的数据量,单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小,然后通知对方以确定对方的发送窗口的上限。
- 校验和: 占 2 字节。校验和字段校验的范围包括首部和数据这两部分。在计算校验和时,要在 TCP 报文段的前面加上 12 字节的伪首部。
- 紧急指针字段: 占 16 bit。紧急指针指出在本报文段中的紧急数据的最后一个字节的
序号。

(2)TCP连接建立的过程

TCP协议通过三次握手来初始化,目的是使数据段的发送和接收同步,告诉其他主机其
一次可接收的数据量,并建立连接。TCP 连接的建立是通过三次握手实现的。需要连接的双方发送自己的同步 SYN 信息给对方,在 SYN 中包含了末端初始的数据序号,并且需要收到对方对自身发出 SYN 的确认。一个典型的 TCP 连接建立的过程如图所示。

![tcpshakesthreetimes](/assets/article/20190629/tcp_shakes_three_times.png)

- 第一步客户机向服务器发送一个 TCP 数据包,表示请求建立连接。 为此,客户端将数据包的 SYN 位设置为 1,并且设置序列号 seq=1000(我们假设为 1000)。
- 第二步服务器收到了数据包,并从 SYN 位为 1 知道这是一个建立请求的连接。于是服务器也向客户端发送一个 TCP 数据包。因为是响应客户机的请求,于是服务器设置 ACK 为1,ack_seq=1001(对方的序列号 1000+1)同时设置自己的序列号。seq=2000(我们假设为2000)。
- 第三步客户机收到了服务器的 TCP,并从 ACK 为 1 和 ack_seq=1001 知道是从服务器来的确认信息。于是客户机也向服务器发送确认信息。客户机设置 ACK=1,和 ack_seq=2001(对方的序列号 2000+1),seq=1001,发送给服务器。至此客户端完成连接。最后一步服务器收到确认信息,也完成连接。接下来就可以在两台主机间传输数据了。

(3)TCP 连接的标识

TCP 是实现两主机间进程的通信,所以只有两个主机的 IP 地址是不能标识一条连接的,在 TCP 中,使用两个 socket 来标识一条连接。Socket 由本地的 IP 地址和进程使用的端口号组成,<本地 IP 地址,本地端口>。这样对于一条 TCP 连接,就可以使用两个一元组来表示为“<本地 IP 地址,本地端口>,<远端 IP 地址,远端端口>”或者使用一个四元组来表示为“<本地 IP 地址,本地端口,远端 IP 地址,远端端口>”。因此,许多的网络应用只使用一个熟知端口,却可以同时支持多个用户的连接。

(4)关闭 TCP 连接

关闭一条 TCP 连接有三种可能的情况:

- 发起连接的一方(主机 A)请求关闭 TCP 连接。在这种情况下,主机 A 发送的数据包中将包含一个 FIN(FINISH,终止信息)控制信息,然后主机 A 将进入 FIN—WAIT 等待状态。在这种状态下,主机 A 仍然可以接收数据,但不能发送数据了。当连接的另一端(主机 B)收到这个数据包后,将发送一个确认数据包,但可能不包括 FIN 控制信息,直到主机 B 完成任务,才发送 FIN。然后 A 端向 B 端发送 FIN 确认信息,这时 B 端变为 CLOSED 状态,A 端延时一段时间后也转换为 CLOSED 状态。
- 主机 B 主动请求关闭 TCP 连接。主机 A 从网络中收到来自主机 B 的 FIN 控制信息,主机A 将通知一层应用连接即将断开,而后当来自 B 端的数据发送完毕后,向 B 端发送 FIN 控制信息,确认后即断开连接。如果当主机 B 上层应用的超时定时器超时后,还没有收到主机A的确认信息,则将主动断开 TCP 连接。
- 主机 A 和主机 B 同时发起断开连接的请求,其过程与上述两种情况大致相同,就不再详细介绍了。

2. UDP 协议

UDP数据包的格式:

![udppacketformat](/assets/article/20190629/udp_packet_format.png)

- 源端口号(16 位):UDP 数据包的发送方使用的端口号。
- 目标端口号(16 位):UDP 数据包的接收方使用的端口号。UDP 协议使用端口号为不同的应用保留其各自的数据传输通道。UDP 和 rap 协议正是采用这一机制,实现对同一时刻内多项应用同时发送和接收数据的支持。
- 数据包长度(16 位)。数据包的长度是指包括包头和数据部分在内的总的字节数。理论上,包含包头在内的数据包的最大长度为 65535 字节。不过,一些实际应用往往会限制数据包的大小,有时会降低到 8192 字节。
- 校验值(16 位)。UDP 协议使用包头中的校验值来保证数据的安全。

UDP协议是一种无连接的协议,因此不需要像TCP那样通过三次握手来建立一个连接。
同时,一个 UDP 应用可同时作为应用的客户或服务器方。由于 UDP 协议并不需要建立一个明确的连接,比建立 UDP 应用要比建立 TCP 应用简单得多。

使用UDP协议工作的服务器,通常是非面向连接的。因而服务器进程不需要像 TCP 协议服务那样建立连接,UDP 服务器只需要在绑定的端口上等待客户机发送来的 UDP 数据报,并对其进行处理和响应即可。

## 网络编程基础

### socket 概述

Socket接口是TCP/IP网络的API。网络的Socket数据传输是一种特殊的I/O,
Socket 也是一种文件描述符。 Socket 也具有一个类似于打开文件的函数调用 Socket(),该函数返回一个整型的 Socket 描述符,随后的连接建立、数据传输等操作都是通过该 Socket实现的。常见的 socket 有以下三种类型。
1. 流式 socket(SOCK_STREAM):流式 socket 提供可靠的、面向连接的通信流。它使用 TCP协议,从而保证了数据传输的正确性。
2. 数据报 socket(SOCK_DGRAM):数据报 socket 定义了一种无连接的服务,它使用 UDP 协议,通过相互独立的数据报传输数据,协议本身不保证传输的可靠性和数据的原始顺序。
3. 原始 socket:原始 socket 允许对底层协议如 IP,进行直接访问,它的功能强大,用户可以通过该 socket 开发自己的协议。

#### 基本数据结构和函数

1. 网络地址

结构体sockaddr:
```c
struct sockaddr {
    unsigned short sa_family; /* 地址族, AF_xxx */
    char sa_data[14]; /* 14 字节的协议地址 */
};
```

结构体sockaddr_in:
```c
struct sockaddr_in {
    short int sin_family; /* 地址族 */
    unsigned short int sin_port; /* 端口号 */
    struct in_addr sin_addr/* IP 地址 */
    unsigned char sin_zero[8]; /* 填充 0 以保持与 struct sockaddr 同样大小 */
};
```

2. IP 地址转换

```c
int inet_aton(const char *cp,struct in_addr *inp)
char *inet_ntoa(struct in_addr in)
```

3. IP和域名的转换

```c
struct hostent *gethostbyname(const char *hostname);
struct hostent *gethostbyaddr(const char *addr,int len,int type);
```

```c
struct hostent{
    char *h_name; /*主机的正式名称 */
    char *h_aliases; /*主机的别名 */
    int h_addrtype; /*主机的地址类型 AF_INET*/
    int h_length; /*主机的地址长度对于IP4是4字节32位*/
    char **h_addr_list; /* 主机的 IP 地址列表 */
} ;
```

4. 字节顺序转换

```c
unsigned long int htonl(unsigned long int hostlong);
unsigned short int htons(unisgned short int hostshort);
unsigned long int ntohl(unsigned long int netlong);
unsigned short int ntohs(unsigned short int netshort);
```

5. 服务信息函数

```c
int getsockname(int sockfd,struct sockaddr *localaddr,int *addrlen);
int getpeername(int sockfd,struct sockaddr *peeraddr, int *addrlen);
struct servent *getservbyname(const char *servname,const char *protoname);
struct servent *getservbyport(int port,const char *protoname);
struct servent {
    char *s_name; /* 正式服务名 */
    char **s_aliases; /* 别名列表 */
    int s_port; /* 端口号 */
    char *s_proto; /* 使用的协议 */
}
```

#### socket基础编程

```c
/**hostname_ip.c**/
#include "stdio.h"
#include "stdlib.h"
#include "errno.h"
#include "sys/types.h"
#include "sys/socket.h"
#include "unistd.h"
#include "netinet/in.h"
#include "netdb.h"
#include "arpa/inet.h"

int main(int argc ,char **argv) {
    struct sockaddr_in addr;
    struct hostent *host;
    char **alias;
    if(argc<2){
        fprintf(stderr,"Usage:%s hostname|ip..\n\a",argv[0]); 
        exit(1);
    }
    argv++;
    for(;*argv!=NULL;argv++) {
        if(inet_aton(*argv,&addr.sin_addr)!=0) {
            host=gethostbyaddr((char *)&addr.sin_addr,4,AF_INET);
			printf("Address information of Ip %s\n",*argv);
        }
        else {
            host=gethostbyname(*argv);
            printf("Address information of host %s\n",*argv);
        }
        if(host==NULL) {
            fprintf(stderr,"No address information of %s\n",*argv);
			continue;
        }
		else{
			printf("Official host name %s\n",host->h_name);
			printf("Name aliases:");
			for(alias=host->h_aliases;*alias!=NULL;alias++){
				printf("%s ,",*alias);
			}
			printf("\nIp address:");
			for(alias=host->h_addr_list;*alias!=NULL;alias++){
				printf("%s ,",inet_ntoa(*(struct in_addr *) (*alias)));
			}
			printf("\n");
		}
    }
}
```

## TCP通信编程

一个典型的通信过程

![TCPcommunicationprocess](/assets/article/20190629/tcp_communication_process.png)

服务器首先启动,通过调用socket()建立一个套接字,然后调用 bind()将该套接字和本地网络地址联系在一起,再调用listen()使套接字做好侦听的准备,并规定它的请求队列的长度,之后就调用accept()来接收连接。客户在建立套接字后就可调用connect()和服务器建立连接。连接一旦建立,客户机和服务器之间就可以通过调用read()和write()来发送和接收数据。最后,待数据传送结束后,双方调用close()关闭套接字。

TCPServer程序设计:

```c
/** tcpserver.c **/
#include<stdlib.h>
#include<stdio.h>
#include<errno.h>
#include<string.h>
#include<netdb.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<sys/socket.h>
#include<arpa/inet.h>

int main(int argc,char *argv[])
{
	int sockfd,new_fd;
	struct sockaddr_in server_addr;
	struct sockaddr_in client_addr;
	int sin_size,portnumber;
	const char hello[] = "Hello I'm tcpserver";
	if(argc != 2){
		fprintf(stderr,"Usage:%s protnumber\a\n",argv[0]);
		exit(1);
	}
	if((portnumber=atoi(argv[1]))<0){	//ascii to integer
		fprintf(stderr,"Usage:%s portnumber\a\n",argv[0]);
		exit(1);
	}

	if((sockfd=socket(AF_INET,SOCK_STREAM,0))==-1){ /*服务器端开始建立 socket 描述符*/
		fprintf(stderr,"Socket error:%s portnumber\a\n",strerror(errno));
		exit(1);
	}
        /*服务器端填充 sockaddr 结构*/
	bzero(&server_addr,sizeof(struct sockaddr_in));
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	server_addr.sin_port = htons(portnumber);

        /*捆绑 sockfd 描述符*/
	if(bind(sockfd,(struct sockaddr *)(&server_addr),sizeof(struct sockaddr)) == -1){
		fprintf(stderr,"Bind error:%s\n\a",strerror(errno));
		exit(1);
	}

        /*监听 sockfd 描述符*/
	if(listen(sockfd,5) == -1){//请求允许最大连接数目
		fprintf(stderr,"Listen error: %s\n\a",strerror(errno));
		exit(1);
	}

	while(1){
                /*服务器阻塞,直到客户程序建立连接*/
		sin_size = sizeof(struct sockaddr_in);
		if((new_fd = accept(sockfd,(struct sockaddr*)(&client_addr),&sin_size))==-1){
			fprintf(stderr,"Accept error:%s \n\a",strerror(errno));
			exit(1);
		}
		fprintf(stderr,"Server get connection from %s\n",inet_ntoa(client_addr.sin_addr));
		if(write(new_fd,hello,strlen(hello))==-1){
			fprintf(stderr,"Write Error: %s\n",strerror(errno));
			exit(1);
		}
		close(new_fd); /*这个通信已经结束*/
                /*循环下一个*/
	}
	close(sockfd);
	exit(0);
}
```

TCP Client程序设计:

```c
/** tcpclient.c **/
#include<stdlib.h>
#include<stdio.h>
#include<errno.h>
#include<string.h>
#include<netdb.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<sys/socket.h>
int main(int argc,char *argv[])
{
	int sockfd;
	char buffer[1024];
	struct sockaddr_in server_addr;
	struct hostent *host;
	int portnumber,nbytes;
	if(argc != 3){
		fprintf(stderr,"Usage:%s hostname protnumber\a\n",argv[0]);
		exit(1);
	}
	if((host=gethostbyname(argv[1]))==NULL){
		fprintf(stderr,"Usage:%s hostname protnumber2\a\n",argv[0]);
		exit(1);
	}
	if((sockfd=socket(AF_INET,SOCK_STREAM,0))==-1){
		fprintf(stderr,"Socket error:%s portnumber\a\n",strerror(errno));
		exit(1);
	}
	if((portnumber=atoi(argv[2]))<0){	//ascii to integer
		fprintf(stderr,"Usage:%s portnumber\a\n",argv[0]);
		exit(1);
	}

	server_addr.sin_family = AF_INET;
	server_addr.sin_port = htons(portnumber);
	server_addr.sin_addr = *((struct in_addr *)host->h_addr);

        /*客户程序发起连接请求*/
	if(connect(sockfd,(struct sockaddr *)(&server_addr),sizeof(struct sockaddr)) == -1){
		fprintf(stderr,"Connect Error: %s \a\n",strerror(errno));
		exit(1);
	}

        /*连接成功了*/
	if((nbytes=read(sockfd,buffer,1024))==-1){
		fprintf(stderr,"Read Error: %s \a\n",strerror(errno));
		exit(1);
	}
	buffer[nbytes] = '\0';
	printf("I have received:%s \n",buffer);
	close(sockfd); /*结束通信*/
	exit(0);
}
```

## UDP通信编程

UDP 是非连接的、不保证可靠性的、传递数据报的传输协议。由于UDP不提供可靠性保证,使得它具有较少的传输时延,因而UDP协议常常用在一些对速度要求较高的场合。UDP 连接的通信过程如图所示。

![UDPcommunicationprocess](/assets/article/20190629/udp_communication_process.png)

在服务器端,服务器首先创建一个 UDP 数据报类型的套接字,然后服务器就调用bind()函数,给此 UDP 套接字绑定一个端口。由于不需要建立连接,因此服务器端就可以通过调用 recvfrom()函数在指定的端口上等待客户端发送来的 UDP 数据报。在客户端,同样要先通过 socket()函数创建一个数据报套接字,然后有操作系统为这个套接字来分配端口号。此后客户端就可以使用 sendto()函数向一个指定的地址发送一个UDP 数据报。服务器端接收到套接字后,从 recvfrom()中返回,在对数据报进行处理之后,再用 sendto()函数将处理的结果返回客户端。 UDP 中使用的函数基本和上节相同。

UDP服务器端程序设计:

```c
/** udpserver.c **/
#include<sys/types.h>
#include<sys/socket.h>
#include<string.h>
#include<netinet/in.h>
#include<stdlib.h>
#include<stdio.h>

#define MAXLINE 80
#define SERV_PORT 8888

void do_echo(int sockfd,struct sockaddr *pcliaddr,socklen_t clilen)
{
	int n;
	socklen_t len;
	char mesg[80];
	for(;;){
		len = clilen;
		n = recvfrom(sockfd,mesg,MAXLINE,0,pcliaddr,&len); /* 等待接收数据 */
		sendto(sockfd,mesg,n,0,pcliaddr,len); /* 将接收到的数据发送回去 */
		mesg[n] = 0;
		fputs(mesg,stdout);
	}
}

int main()
{
	int sockfd;
	struct sockaddr_in servaddr,cliaddr;
	sockfd = socket(AF_INET,SOCK_DGRAM,0); /* 创建 socket */
	bzero(&servaddr,sizeof(servaddr)); /* 初始化 servaddr */
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY); /*定义为 INADDR_ANY*/
	servaddr.sin_port = htons(SERV_PORT);
	if(bind(sockfd,(struct sockaddr *)&servaddr,sizeof(servaddr))==-1) /* 绑定 IP 地址和端口*/
	{
		perror("bind error");
		exit(1);
	}
	do_echo(sockfd,(struct sockaddr *)&cliaddr,sizeof(cliaddr));
	return 0;
}
```

UDP客户端程序设计:

```c
/** udpclient.c **/
#include<sys/types.h>
#include<sys/socket.h>
#include<string.h>
#include<netinet/in.h>
#include<stdlib.h>
#include<stdio.h>
#include<arpa/inet.h>
#include<unistd.h>

#define MAXLINE 80
#define SERV_PORT 8888

void do_cli(FILE *fp,int sockfd,struct sockaddr *pservaddr,socklen_t servlen)
{
	int n;
	char sendline[MAXLINE],recvline[MAXLINE+1];
	if(connect(sockfd,(struct sockaddr *)pservaddr,servlen)==-1){ /* 连接服务器 */
		perror("conect error");
		exit(1);
	}
	while(fgets(sendline,MAXLINE,fp) != NULL){
		write(sockfd,sendline,strlen(sendline)); /*读一行并发送到服务器*/
		n = read(sockfd,recvline,MAXLINE); /* 接收从服务器来的数据 */
		if(n == -1){
			perror("read error");
			exit(1);
		}
		recvline[n] = 0;
		fputs(recvline,stdout);
	}
}
int main(int argc,char *argv[])
{
	int sockfd;
	struct sockaddr_in servaddr;
	if(argc != 2){
		printf("Usage:udpclient<IPaddress>\n");
		exit(1);
	}
	bzero(&servaddr,sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port = htons(SERV_PORT);
	if(inet_pton(AF_INET,argv[1],&servaddr.sin_addr)<=0)
	{
		printf("[%s]is not a valid IPaddress\n",argv[1]);
		exit(1);
	}
	sockfd = socket(AF_INET,SOCK_DGRAM,0);
	do_cli(stdin,sockfd,(struct sockaddr *)&servaddr,sizeof(servaddr));
	return 0;
}
```
