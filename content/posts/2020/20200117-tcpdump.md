---
title: "Tcpdump快速入门"
date: 2020-01-17T10:32:56+08:00
tags: ["tcpdump"]
toc: true
categories: ['Linux','Tool']
---

`TCPDUMP`毫无疑问是一个重要的网络分析工具，因为它在一个界面中既提供了功能又满足了简便性。学习tcpdump也更能促进对TCP/IP协议栈的理解。
<!--more-->

本教程将向您展示如何以各种方式隔离流量（从IP，端口，协议到应用程序层流量），以确保您尽快找到所需的信息。

### Option

+ **-i any** 监听所有的网卡接口，用来查看是否有网络流量
+ **-i eth0** 只监听eth0网卡接口
+ **-l** 行可读输出（用于保存时查看或发送至其他命令）
+ **-D** 显示可用的接口列表
+ **-n** 不要解析主机名
+ **-nn** 不要解析主机名或者端口名
+ **-q** 显示更少的输出(更加quiet)
+ **-t** 输出可读的时间戳
+ **-tttt** 输出最大程度可读的时间戳
+ **-X** 以hex和ASCII两种形式显示包的内容
+ **-XX** 与 **-X** 类似，增加以太网header的显示
+ **-v, -vv, -vvv** 显示更加多的包信息
+ **-c** 只读取x个包，然后停止
+ **-s** 指定每一个包捕获的长度，单位是byte，使用`-s0`可以捕获整个包的内容
+ **-S** 输出绝对的序列号
+ **-e** 获取以太网header
+ **-E** 使用提供的秘钥解密IPSEC流量

然我们从一个简单的获取https流量的命令开始
```
tcpdump -nnSX port 443
```

这将以16进制的形式显示加密后的HTTPS流量，你可以按你的需要来更改端口号

### Examples

**捕获所有流量**

```
tcpdump -i any
```

**捕获指定网卡流量**

```
tcpdump -i eth0
```

**获取指定IP流量**

```
tcpdump host 1.1.1.1
```

**通过源/目的IP过滤流量**

```
tcpdump src 1.1.1.1
tcpdump dst 1.0.0.1
```

**通过子网获取数据包**

```
tpcdump net 1.2.3.0/24
```

**获取数据包十六进制输出内容**

```
tcpdump -c 1 -X icmp
```

> 当您想查看有问题的数据包的内容时，十六进制输出很有用，而当您隔离一些候选者进行仔细检查时，通常最好使用十六进制输出。

**显示指定端口的流量信息**

```
tcpdump port 3389
tcpdump src port 1025
```

**显示指定协议的流量信息**

```
tcpdump icmp
```
> 你可以使用tcp,udp,icmp等其他协议

**显示IPv6流量**

```
tcpdump ip6
```

**查找某个端口范围内流量**

```
tcpdump portrange 21-23
```

**获取指定数据包大小的流量**

```
tcpdump less 32
tcpdump geater 64
tcpdump <= 128
```

**保存捕获的数据包流量**

```
tcpdump port 80 -w capture_file
```
> 将数据包捕获保存到文件中以供将来分析通常很有用。 这些文件被称为PCAP（PEE-cap）文件，它们可以由数百种不同的应用程序处理，包括网络分析仪，入侵检测系统，当然也可以由tcpdump本身处理。

**查看保存后的数据**

```
tcpdump -r capture_file
```

### Advanced

**About the Combinations**

1. AND

    `and` or `&&`

2. OR

    `or` or `||`

3. EXCEPT

    `not` or `!`

**原生输出**

```
tcpdump -ttnnvvS
```

**源IP和目的端口**

```
tcpdump -nnvvS src 10.5.2.3 and dst port 3389
```

**源子网目的子网**

```
tcpdump -nvX src net 192.168.0.0/16 and dst net 10.0.0.0/8 or 172.16.0.0/16
```

**目的IP非ICMP包**

```
tcpdump dst 192.168.0.2 and src net and not icmp
```

**非指定端口的指定主机的流量**

```
tcpdump -vv src mars and not dst port 22
```

**复杂分组和特殊字符**

tcpdump 'src 10.0.2.3 and (dst port 3389 or 22)'

> 括号在shell中会被解析，可以对括号转义或使用单引号

隔离指定TCP标识:

下面的过滤规则中，**tcp[13]** 表示在TCP header中的偏移位置13开始，后面的数字代表了匹配的byte数

**RST标志**

```
tcpdump 'tcp[13] & 4!=0'
tcpdump 'tcp[tcpflags] == tcp-rst'
```

**SYN标志**

```
tcpdump 'tcp[13] & 2!=0'
tcpdump 'tcp[tcpflags] == tcp-syn'
```

**SYN and ACK标志**

```
tcpdump 'tcp[13]=18'
```

**URG标志**

```
tcpdump 'tcp[13] & 32!=0'
tcpdump 'tcp[tcpflags] == tcp-urg'
```

**ACK标志**

```
tcpdump 'tcp[13] & 16!=0'
tcpdump 'tcp[tcpflags] == tcp-ack'
```

**PSH标志**

```
tcpdump 'tcp[13] & 8!=0'
tcpdump 'tcp[tcpflags] == tcp-psh'
```

**FIN标志**

```
tcpdump 'tcp[13] & 1!=0'
tcpdump 'tcp[tcpflags] == tcp-fin'
```

### Instance

既然已经解决了理论问题，这里有一些快速的方法可以用来捕捉各种各样的流量

**同时设置了SYN and RST标志的包**

```
tcpdump 'tcp[13] = 6'
```

> 事实上正常情况下不会发生

**过滤HTTP User-Agent**

```
tcpdump -vvAls0 | grep 'User-Agent:'
```

**过滤明文HTTP GET请求**

```
tcpdump -vvAls0 | grep 'GET'
```

**过滤HTTP HOST**

```
tcpdump -vvAls0 | grep 'Host:'
```

**过滤HTTP Cookies**

```
tcpdump -vvAls0 | grep 'Set-Cookie|Host:|Cookie:'
```

> grep的或操作符可能需要转义

**通过横幅文本过滤任意端口的SSH连接**

```
tcpdump 'tcp[(tcp[12]>>2):4] = 0x5353482D'
```

**过滤DNS流量**

```
tcpdump -vvAs0 port 53
```

**过滤FTP流量**

```
tcpdump -vvAs0 port ftp or ftp-data
```

**过滤NTP(Network Time Protocol)流量**

```
tcpdump -vvAs0 port 123
```

**过滤明文密码**

```
tcpdump port http or port ftp or port smtp or port imap or port pop3 or port telnet -lA | egrep -i -B5 'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd= |password=|pass:|user:|username:|password:|login:|pass |user '
```

**过滤恶意包**

```
tcpdump 'ip[6] & 128 != 0'
```

> IP标头中有一个永远不会被合法应用程序设置的位，我们称之为“邪恶位”。这是一个有趣的过滤器，用于查找切换位置的数据包。


[参考]

[A tcpdump Tutorial with Examples — 50 Ways to Isolate Traffic](https://danielmiessler.com/study/tcpdump/#basic-communication)

