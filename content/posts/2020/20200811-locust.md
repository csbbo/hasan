---
title: "性能测试工具Locust"
date: 2020-08-11T11:04:49+08:00
categories: ["Python"]
tags: ["Locust"]
toc: true
---

Locust原意蝗虫，"蝗虫过境，寸草不生"。Locust生成的并发请求就如同一大群蝗虫一样对被测系统发起攻击以此检测系统的承压能力。在模拟有效并发方面，Locust的优势在于其摒弃了进程和线程，完全基于事件驱动，使用gevent提供的非阻塞IO和coroutine来实现网络层的并发请求，因此即使是单台压力机也能产生数千并发请求数；再加上对分布式运行的支持，理论上来说，Locust能在使用较少压力机的前提下支持极高并发数的测试。

<!--more-->

先看一个简单的示例`locust_demo.py`

```python
import random
from locust import HttpUser, TaskSet, task, between
import json
import urllib3

urllib3.disable_warnings()


class WebsiteTasks(TaskSet):
    def __init__(self, *args, **kw):
        TaskSet.__init__(self, *args, **kw)

        self.headers = {
            'Content-Type': 'application/json;charset=UTF-8',
            'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36'
        }

    @task(1)
    def get_license(self):
        r = self.client.get('/api/LicenseAPI')

    @task(3)
    def get_label(self):
        r = self.client.get('/api/LabelAPI')

    @task(5)
    def get_user_info(self):
        r = self.client.get('/api/UserInfoAPI')

    def on_start(self):
        try:
            r = self.client.get('/api/CSRFTokenAPI', verify=False)
            self.headers['x-csrftoken'] = r.headers['Set-Cookie'].split(';')[0].split('=')[-1]

            data = json.dumps({
                'username': 'admin',
                'password': 'admin'
            })
            r = self.client.post('/api/LoginAPI', data=data, headers=self.headers, verify=False)
            self.headers['x-csrftoken'] = r.headers['Set-Cookie'].split(';')[0].split('=')[-1]
        except:
            print('登录失败!')

    def on_stop(self):
        r = self.client.post('/api/LogoutAPI', headers=self.headers, verify=False)


class WebsiteUser(HttpUser):
    tasks = [WebsiteTasks]
    wait_time = between(1, 5)
    host = 'https://127.0.0.1'


if __name__ == '__main__':

    import os
    port = 9000
    os.system(f"open http://localhost:{port}")
    os.system(f"locust -f locust_demo.py  --web-port {port}")
```

> Locust发送HTTP请求其实用的就是requests库，这里也完全可以像requests一样使用Locust的client发送请求。`verify=False`关闭https站点的证书认证,配合`urllib3.disable_warnings()`使用关闭警告信息。


### HttpUser

HttpUser表示一个用户，用来攻击进行负载测试的系统。它的行为由task定义，task可以通过使用@task装饰器直接在类上声明，或设置tasks属性在类上声明。

**client=None**  

Locust在实例化时创建的一个HttpSession实例，client支持cookies，因此在HTTP请求时会保持session会话

**tasks=[]**  

Locust将要执行的可调用函数或TaskSet类。如果tasks是一个列表则随机选择列表中的任务执行

**wait_time()**  

返回两个任务执行的间隔时间

**host**  

待测试是主机地址

### TaskSet

定义一个Locust User将要执行的tasks集合，在TaskSet运行时候他将会随机选择一个task执行，然后睡眠wait_time所指定的时间

**on_start()**  

在每个用开始执行之前调用

**on_stop()**  

在每个用户停止执行之后调用

### 单进程运行
```shell
locust -f locust_demo.py
```

> 示例中将这一部分写到了程序里所以也可以通过`python3 locust_demo.py`执行

### 多进程分布式运行

不管是单机多进程还是多机负载模式运行方式均一样

启动master
```shell
locust -f locust_demo.py --master
```

启动worker
```shell
locust -f locust_demo.py --worker   # 单机多进程
locust -f locust_demo.py --worker --master-host<master machine ip>  # 多机负载
```

> 更多的locust用法参见`locust --help`

### 结果展示

当master和slave都启动完毕后可以在浏览器访问`http://master_machine_ip:8089`进入web管理页面，单进程与多进程web使用方式一样，在web管理界面也能看到实际的salve数量。


Locust的结果展示十分简单,主要就几个指标并发用户数、RPS、响应时间、异常率，但对于大多数场景来说已经足够了。

<img src="/assets/2020/0811/statistics.png"/>

在Charts栏可以看到性能指标走势，通过趋势图方式可以非常直观的看到RPS、响应时间、请求用户数的变化情况。
<img src="/assets/2020/0811/charts.png"/>

> 如果想知道被测系统的资源消耗情况可以通过例如`top`等工具来查看

[参考]

[Locust官方文档](https://docs.locust.io/en/stable/api.html?highlight=HttpUser#httpuser-class)  
[深入浅出开源性能测试工具 Locust](https://debugtalk.com/post/head-first-locust-user-guide/)  
