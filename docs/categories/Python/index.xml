<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on 庄周梦蝶</title>
    <link>http://blog.shaobo.fun/categories/Python/</link>
    <description>Recent content in Python on 庄周梦蝶</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Jul 2020 14:46:00 +0800</lastBuildDate>
    
	<atom:link href="http://blog.shaobo.fun/categories/Python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>记一次Evenlet事件</title>
      <link>http://blog.shaobo.fun/posts/2020/20200706-elvenlet-problem/</link>
      <pubDate>Mon, 06 Jul 2020 14:46:00 +0800</pubDate>
      
      <guid>http://blog.shaobo.fun/posts/2020/20200706-elvenlet-problem/</guid>
      <description>&lt;p&gt;事情的起因是要再项目中使用双向通信，首选是websocket但是由于ie10的不支持选用的socketio(sockerio会根据实际情自动切换websocket和轮询两种办法),而socketio的使用又需要引入evenlet,就这样一步一步的往里陷了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python性能分析</title>
      <link>http://blog.shaobo.fun/posts/2020/20200410-line-profiler-memory-profiler/</link>
      <pubDate>Fri, 10 Apr 2020 14:12:45 +0800</pubDate>
      
      <guid>http://blog.shaobo.fun/posts/2020/20200410-line-profiler-memory-profiler/</guid>
      <description>&lt;p&gt;对代码优化的前提是需要了解性能瓶颈在什么地方，程序运行的主要时间和内存是消耗在哪里。line_profiler和memory_profiler就能够很好的帮我们定位到时间和内存都消耗在哪里了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>分布式系统心跳检查</title>
      <link>http://blog.shaobo.fun/posts/2020/20200207-heartbeat-detection/</link>
      <pubDate>Fri, 07 Feb 2020 23:40:02 +0800</pubDate>
      
      <guid>http://blog.shaobo.fun/posts/2020/20200207-heartbeat-detection/</guid>
      <description>&lt;p&gt;在分布式系统中经常使用心跳(Heartbeat)来检测Server的健康状况，传统的检测方法是设定一个超时时间T，只要在T之内没有接收到对方的心跳包便认为对方宕机，方法简单粗暴，但使用广泛。从理论上来说，心跳无法真正检测对方是否crash，主要困难在于无法真正区别对方是宕机还是“慢”。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Django ORM 查询</title>
      <link>http://blog.shaobo.fun/posts/2020/20200113-django-complex-query-orm/</link>
      <pubDate>Mon, 13 Jan 2020 11:03:42 +0800</pubDate>
      
      <guid>http://blog.shaobo.fun/posts/2020/20200113-django-complex-query-orm/</guid>
      <description>&lt;p&gt;django orm其实还是很简单的，学起来也容易，这篇文章更多也是辅助记忆，方便日后查找。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>下载Bing每日壁纸</title>
      <link>http://blog.shaobo.fun/posts/2019/20191221-bing-dynamic-theme/</link>
      <pubDate>Sat, 21 Dec 2019 20:23:46 +0800</pubDate>
      
      <guid>http://blog.shaobo.fun/posts/2019/20191221-bing-dynamic-theme/</guid>
      <description>&lt;p&gt;Bing首页每日更新的壁纸非常漂亮，爬下来当做桌面壁纸很nice。
Bing中提供了8天内的壁纸，而又以每天为参考一次最多可获取最近8天的壁纸。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python内置函数</title>
      <link>http://blog.shaobo.fun/posts/2019/20191219-python-build-in-function/</link>
      <pubDate>Thu, 19 Dec 2019 10:54:56 +0800</pubDate>
      
      <guid>http://blog.shaobo.fun/posts/2019/20191219-python-build-in-function/</guid>
      <description>&lt;p&gt;Python 解释器内置了很多函数和类型，您可以在任何时候使用它们。以下按字母表顺序列出它们。
&lt;br&gt;&lt;br&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 并发编程</title>
      <link>http://blog.shaobo.fun/posts/2019/20191218-python-concurrent-programming/</link>
      <pubDate>Wed, 18 Dec 2019 19:28:13 +0800</pubDate>
      
      <guid>http://blog.shaobo.fun/posts/2019/20191218-python-concurrent-programming/</guid>
      <description>&lt;p&gt;对于并发编程, Python有多种长期支持的方法, 包括多线程, 调用子进程, 以及各种各样的关于生成器函数的技巧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python单例模式实现</title>
      <link>http://blog.shaobo.fun/posts/2019/20191205-python-singleton-pattern/</link>
      <pubDate>Thu, 05 Dec 2019 13:46:02 +0800</pubDate>
      
      <guid>http://blog.shaobo.fun/posts/2019/20191205-python-singleton-pattern/</guid>
      <description>&lt;p&gt;单例是一种设计模式，使用该模式的类只会生成一个实例。单例模式保证了在程序不同位置都可以读取到同一对象实例，如果实例不存在则创建，已存在则返回这个实例。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>